<!DOCTYPE html>
<!--
PlasmaFractal main script. Copyright (c) 2019 zett42.
https://github.com/zett42/PlasmaFractal

MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE. 
-->
<html lang="us">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1">	

	<title>zett42 PlasmaFractal</title>

	<link href="external/jquery-ui/jquery-ui.css" rel="stylesheet">
	<link href="external/spectrum/spectrum.css" rel="stylesheet">
	<link href="external/spectrum/sp-dark.css" rel="stylesheet">

	<style>

	html, body { 
		margin:0; padding:0;
		width:100%; 
		height:100%; 
		overflow: hidden;
		background: black;
	} 
	canvas {
		margin:0; padding:0;
		display: block;  /* To remove the scrollbars */
		background: black;
	}
	input {
		padding-left: 5px;
	}
	#dialog-link {		
		margin:0; padding: 0 0 5px 1px;
		
		position: absolute;
		left: 15px; 
		top: 15px;
		width: 1.5em; 
		height: 1.5em;

		font-size: 20px;
	}
	#dialog {
		display: none;
	}
	#dialog a {
		font-size: 12px;
	}
	.ui-dialog {
		opacity:   .85 !important; /* Make sure to change both of these, as IE only sees the second one */
		filter:    Alpha(Opacity=85) !important;
		font-size: 14px !important;
	}
    .ui-dialog-titlebar-close { 
		width: 30px !important; height: 26px !important; top: 40% !important; 
	}
	#paletteEasingGroup {
		display: flex;
		flex-wrap: nowrap;
	}
	#paletteEasingGroup > div {
		flex-grow: 1;	
	}
	.selectOverflow { height: 350px; }	
	</style>
</head>
<body>

<button id="dialog-link" title="Plasma Options" class="ui-button ui-corner-all ui-widget">âš™</button>

<div id="dialog" title="Plasma Options">
	<a href="https://github.com/zett42/PlasmaFractal" target="_blank" rel="noopener">github.com/zett42/PlasmaFractal</a>
	<p/>
	
	<div id="tabs">
		<ul>
			<li><a href="#tabs-params">Noise</a></li>
			<li><a href="#tabs-palette">Palette</a></li>
			<li><a href="#tabs-animation">Animation</a></li>
		</ul>
		
		<div id="tabs-params">
			<p>
			<label for="frequencyInput">Frequency: 
			<input id="frequencyInput" type="number" step="0.1" style="width:6em;">
			</p>
			<div id="frequencySlider"></div>
			
			<p><label for="octavesSlider">Octaves:</label></p>
			<div id="octavesSlider"></div>

			<p><label for="gainSlider">Gain:</label></p>
			<div id="gainSlider"></div>	

			<p><label for="lacunaritySlider">Lacunarity:</label></p>
			<div id="lacunaritySlider"></div>
			
			<p><label for="amplitudeSlider">Amplitude:</label></p>
			<div id="amplitudeSlider"></div>
		</div>

		<div id="tabs-palette">
			<div id="paletteEasingGroup">
				<div>
					<p><label for="paletteEasingBgToFg">BG to FG easing:</label></p>
					<select id="paletteEasingBgToFg"></select>	    
				</div>
				<div>	
					<p><label for="paletteEasingFgToBg">FG to BG easing:</label></p>
					<select id="paletteEasingFgToBg"></select>	
				</div>
			</div>

			<p><label for="paletteSaturationSlider">Foreground saturation:</label></p>
			<div id="paletteSaturationSlider"></div>
			
			<p><label for="paletteValueSlider">Foreground brightness:</label></p>
			<div id="paletteValueSlider"></div>
			
			<p>
			<label for="bgColorPicker">Background color:</label>
			<input id="bgColorPicker" />
			</p>
			
			<p>
			<input type="checkbox" id="grayScaleCheckBox">
			<label for="grayScaleCheckBox">Show original grayscale image</label>
			</p>
			
		</div>
			
		<div id="tabs-animation">
			<p><label for="animationSpeedSlider">Palette animation speed:</label></p>
			<div id="animationSpeedSlider"></div>		

			<p><label for="paletteConstantSlider">Palette constant duration:</label></p>
			<div id="paletteConstantSlider"></div>		

			<p><label for="paletteTransitionSlider">Palette transition duration:</label></p>
			<div id="paletteTransitionSlider"></div>		
		</div>
	</div>	
</div>	

<canvas id="canvas">PlasmaFractal</canvas>	

<script src="external/jquery/jquery.js"></script>
<script src="external/jquery-ui/jquery-ui.js"></script>
<script src="external/jquery.dialogOptions.js"></script>
<script src="external/jquery.ui.touch-punch.js"></script>
<script src="external/spectrum/spectrum.js"></script>
<script src="external/perlin.js"></script>	

<script src="z42easing.js"></script>	
<script src="z42color.js"></script>	
<script src="z42FractalNoise.js"></script>

<script>
(function () {

	//===================================================================================================================
	// Plasma parameters
	//===================================================================================================================
	
	let plasmaParams = {
		frequency  : 2,    // increase for smaller structures
		octaves    : 8,    // number of passes (level of detail, typically 1 to 8)
		gain       : 0.4,  // how much amplification for each pass (typically 0.3 to 0.7, default 0.5)
		lacunarity : 2,    // frequency multiplicator for each pass (default 2)	
		amplitude  : 1     // output of noise function (default 1)
	};

	const paletteColorCount = 2;   // simultaneous colors on screen
	
	const easeFunctions = [
		"Linear",
		"InQuad",
		"OutQuad",
		"InOutQuad",
		"InCubic",
		"OutCubic",
		"InOutCubic",
		"InQuart",
		"OutQuart",
		"InOutQuart",
		"InQuint",
		"OutQuint",
		"InOutQuint",
		"InSine",
		"OutSine",
		"InOutSine",
		"InExpo",
		"OutExpo",
		"InOutExpo",
		"InExpo2",
		"OutExpo2",
		"InOutExpo2",
		"InCirc",
		"OutCirc",
		"InOutCirc",
		"InBounce",
		"OutBounce",
		"InOutBounce"
	];

	let paletteEaseFunctionBgToFg = "InCubic";
	let paletteEaseFunctionFgToBg = "OutExpo2";
		
	let paletteSaturation = 0.5;
	let paletteValue      = 0.75;
		
	let backgroundRGBA = { r: 0, g: 0, b: 0, a: 255 };

	let animationSpeed = 0.15;

	let paletteConstantMillis   = 10 * 1000;  // Time in ms during which palette won't change.
	let paletteTransitionMillis =  5 * 1000;  // Time in ms for palette transition.

	// Set true for debugging, to see true output of noise function.
	let isGrayScale = false;
	
	const startTime = performance.now();

	const noiseSeed = Math.random();
	//const noiseSeed = 0;   // to create same start image

	//===================================================================================================================
	// Plasma state variables
	//===================================================================================================================
	
	let plasmaPixels     = null;
	let context          = null;
	let contextImageData = null;
	let contextPixels    = null;
	
	// Palette size must be big enough to allow for multiple smooth gradients. 
	// 256 entries per color seem to be way too little (gradients won't be smooth)! Minimum entries for complex gradients
	// seems to be 1024.
	let startPalette      = new Uint32Array( new ArrayBuffer( paletteColorCount * 2048 * Uint32Array.BYTES_PER_ELEMENT ) );
	let nextPalette       = new Uint32Array( new ArrayBuffer( startPalette.length * Uint32Array.BYTES_PER_ELEMENT ) );
	let transitionPalette = new Uint32Array( new ArrayBuffer( startPalette.length * Uint32Array.BYTES_PER_ELEMENT ) );
	let currentPalette    = new Uint32Array( new ArrayBuffer( startPalette.length * Uint32Array.BYTES_PER_ELEMENT ) );
	let grayScalePalette  = new Uint32Array( new ArrayBuffer( startPalette.length * Uint32Array.BYTES_PER_ELEMENT ) );
	let paletteFirstHue = 0;
	
	let isPaletteTransition = false;   // Palette currently transitioning to next palette?
	let paletteStartTime = startTime;  // Start time of current phase (constant or transition).
	
	//===================================================================================================================
	// Functions
	//===================================================================================================================

	// Draw noise image with animated palette in canvas.

	function drawInCanvas() 
	{
		if( isGrayScale )
		{
			z42color.drawImageUint16WithPalette( contextPixels, plasmaPixels, grayScalePalette );		
		}
		else
		{
			animatePalette();
	
			z42color.drawImageUint16WithPalette( contextPixels, plasmaPixels, currentPalette );
		}

		context.putImageData( contextImageData, 0, 0 );	
		
		window.requestAnimationFrame( drawInCanvas );	
	}	
	
	//-------------------------------------------------------------------------------------------------------------------

	function animatePalette()
	{
		const curTime         = performance.now();
		const totalDuration   = curTime - startTime;
		const paletteDuration = curTime - paletteStartTime;		
		let paletteOffset     = totalDuration * animationSpeed * startPalette.length / 4096;
	
		let paletteToRotate = null;
	
		if( isPaletteTransition )
		{
			if( paletteDuration <= paletteTransitionMillis )
			{
				// Still in transition phase.
				let alpha = paletteDuration / paletteTransitionMillis;
				z42color.blendPalette( startPalette, nextPalette, transitionPalette, alpha );

				paletteToRotate = transitionPalette;
			}
			else
			{
				// Transition phase finished. Start the constant phase.
				isPaletteTransition = false;
				paletteStartTime = curTime;
				
				// swap startPalette, nextPalette
				[ startPalette, nextPalette ] = [ nextPalette, startPalette ];

				paletteToRotate = startPalette;
			}			
		}
		else
		{
			if( paletteDuration > paletteConstantMillis )
			{
				// Constant phase finished. Start the transition phase.
				isPaletteTransition = true;
				paletteStartTime = curTime;

				generatePalette( nextPalette, Math.random() ); 
			}
			// else still in constant phase. Nothing to do.

			paletteToRotate = startPalette;
		}

		z42color.rotatePalette( paletteToRotate, currentPalette, paletteOffset );
	}
	
	//-------------------------------------------------------------------------------------------------------------------

	function updatePalette()
	{
		generatePalette( startPalette, paletteFirstHue );
		
		isPaletteTransition = false;
		paletteStartTime = performance.now();		
	}
	
	//-------------------------------------------------------------------------------------------------------------------
	// Generate a beautiful loopable palette with random start color. Subsequent colors will be generated by adding
	// golden ratio to hue value, which creates nices contrasts.

	function generatePalette( palette, firstHue )
	{
		paletteFirstHue	= firstHue;
	
		let colorHsv = { 
			h : firstHue,   
			s : paletteSaturation, 
			v : paletteValue,
			a : 1  // alpha
		};

		const bgToFgFunction = z42easing[ "ease" + paletteEaseFunctionBgToFg ];
		const fgToBgFunction = z42easing[ "ease" + paletteEaseFunctionFgToBg ];
		
		let palIndex = 0;
		const palRange = palette.length / paletteColorCount / 2;

		for( let i = 0; i < paletteColorCount; ++i )
		{
			const colorRGBA = z42color.nextGoldenRatioColorRGBA( colorHsv ); 
		
			palIndex = z42color.makePaletteGradientRGBA( palette, palIndex, palRange, backgroundRGBA, colorRGBA, bgToFgFunction );
			palIndex = z42color.makePaletteGradientRGBA( palette, palIndex, palRange, colorRGBA, backgroundRGBA, fgToBgFunction );			
		}
	}
	
	//-------------------------------------------------------------------------------------------------------------------
	// Resize the image buffers to the size of the canvas and generate fractal noise image (grayscale).

	function resizeCanvas() 
	{
		canvas.width  = window.innerWidth;
		canvas.height = window.innerHeight;

		plasmaPixels = new Uint16Array( new ArrayBuffer( canvas.width * canvas.height * Uint16Array.BYTES_PER_ELEMENT ) );

		if( canvas.getContext )
		{
			context = canvas.getContext('2d');	
			contextImageData = context.createImageData( canvas.width, canvas.height );
			contextPixels = new Uint32Array( contextImageData.data.buffer );
		}	

		generateFractalImage();
	}
	
	//-------------------------------------------------------------------------------------------------------------------

	function generateFractalImage()
	{
		const fracStartTime = performance.now();

		z42fractal.generateFractalNoiseImageUint16( plasmaPixels, canvas.width, canvas.height, currentPalette.length, plasmaParams ); 

		console.log( "Fractal generation took %d ms", performance.now() - fracStartTime );
	}

	//-------------------------------------------------------------------------------------------------------------------
	
	function toggleFullscreen()
	{
		if( document.documentElement.requestFullscreen )
		{
			if( ! document.fullscreenElement )
				document.documentElement.requestFullscreen();
			else	
				document.exitFullscreen();
		}	
	}

	//-------------------------------------------------------------------------------------------------------------------
	
	function reseedFractal()
	{
		noise.seed( Math.random() );
		generateFractalImage();
	}

	//-------------------------------------------------------------------------------------------------------------------
	
	function initGui()
	{
		$('input').addClass("ui-widget-content ui-corner-all ui-widget");

		$("#button").button();

		$("#dialog-link").click( function( event ) {

			$("#dialog").dialog({
				position: { my: "left top", at: "left+15 top+50" },			
				width: 400,
				// powered by jquery.dialogOptions.js
				clickOut: true,      // closes dialog when clicked outside
				responsive: true,    // fluid width & height based on viewport
				scaleW: 0.9,         // responsive scale height percentage of viewport (0..1)
				scaleH: 0.9,         // responsive scale width percentage of viewport (0..1)
				showTitleBar: true,  // false: hide titlebar

				create: onParamsDialogCreate
			});
		});
	}

	//-------------------------------------------------------------------------------------------------------------------
	
	function onParamsDialogCreate( event, ui )
	{
		function calcSliderValueFromInput( inputValue, minValue, maxValue, minSlider, maxSlider )
		{
			let result = 0;
			if( inputValue < 1 )
				result = minSlider - minSlider * ( inputValue - minValue ) / ( 1 - minValue );  
			else
				result = maxSlider * ( inputValue - 1 ) / ( maxValue - 1 );

			return z42color.clamp( result, minSlider, maxSlider );
		}		
		
		function calcInputValueFromSlider( sliderValue, minValue, maxValue, minSlider, maxSlider )
		{
			if( sliderValue < 0 )
				return minFreq + ( 1 - ( sliderValue / minSlider ) ) * ( 1 - minFreq );
			else
				return 1 + ( sliderValue / maxSlider ) * ( maxFreq - 1 );
		}
		
		$("#tabs").tabs();		
		
		//----- Params Tab -----
				
		const minFreq = 0.05;
		const maxFreq = 15;
		const maxSlider = 90;                // positive positions set frequency from 1 to maxFreq
		const minSlider = -maxSlider / 3;    // negative positions set frequency from minFreq to 1
		
		$("#frequencyInput")
			.val( plasmaParams.frequency )
			.change(function() {
				plasmaParams.frequency = $(this).val();	
				const newSliderVal = calcSliderValueFromInput( plasmaParams.frequency, minFreq, maxFreq, minSlider, maxSlider );
				$("#frequencySlider").slider( "value", newSliderVal );
				
				generateFractalImage();
			});
				
		$("#frequencySlider").slider({
			min  : minSlider,
			max  : maxSlider,
			value: calcSliderValueFromInput( plasmaParams.frequency, minFreq, maxFreq, minSlider, maxSlider ),

			slide: function( event, ui ) {
				plasmaParams.frequency = calcInputValueFromSlider( ui.value, minFreq, maxFreq, minSlider, maxSlider );
				$("#frequencyInput").val( plasmaParams.frequency );
			},
			change: function( event, ui ) {
				generateFractalImage();
			}
		});		
		
		$("#octavesSlider").slider({
			min  : 1,
			max  : 10,
			value: plasmaParams.octaves,   

			slide: function( event, ui ) {
				plasmaParams.octaves = ui.value;
			},
			change: function( event, ui ) {
				generateFractalImage();
			}
		});

		$("#gainSlider").slider({
			min  : 0.2 * 100,
			max  : 0.8 * 100,
			value: plasmaParams.gain * 100,   

			slide: function( event, ui ) {
				plasmaParams.gain = ui.value / 100;
			},
			change: function( event, ui ) {
				generateFractalImage();
			}
		});	
		
		$("#lacunaritySlider").slider({
			min  : 2 * 100,
			max  : 20 * 100,
			value: plasmaParams.lacunarity * 100,   

			slide: function( event, ui ) {
				plasmaParams.lacunarity = ui.value / 100;
			},
			change: function( event, ui ) {
				generateFractalImage();
			}
		});	
		
		$("#amplitudeSlider").slider({
			min  : 1 * 100,
			max  : 10 * 100,
			value: plasmaParams.amplitude * 100,   

			slide: function( event, ui ) {
				plasmaParams.amplitude = ui.value / 100;
			},
			change: function( event, ui ) {
				generateFractalImage();
			}
		});	

		//----- Palette Tab -----
		
		const smBgToFg = $("#paletteEasingBgToFg");
		const smFgToBg = $("#paletteEasingFgToBg");
		
		easeFunctions.forEach( function( name, index ){
			appendOption( smBgToFg, { text: name, selected: name == paletteEaseFunctionBgToFg } );
			appendOption( smFgToBg, { text: name, selected: name == paletteEaseFunctionFgToBg } );
		});

		smBgToFg.selectmenu({
			width: 140,
			position: { my: "left top", at: "left bottom", collision: "flip" },
			select: function( event, ui ) { 
				paletteEaseFunctionBgToFg = ui.item.value;
				updatePalette();
			}
		})
		.selectmenu( "menuWidget" )
        .addClass( "selectOverflow" );
		
		smFgToBg.selectmenu({
			width: 140,
			position: { my: "left top", at: "left bottom", collision: "flip" },
			select: function( event, ui ) { 
				paletteEaseFunctionFgToBg = ui.item.value;
				updatePalette();
			}
		})
		.selectmenu( "menuWidget" )
        .addClass( "selectOverflow" );
	
		
		$("#paletteSaturationSlider").slider({
			min  : 0,
			max  : 100,
			value: paletteSaturation * 100,   

			slide: function( event, ui ) {
				paletteSaturation = ui.value / 100;
				updatePalette();
			}
		});			

		$("#paletteValueSlider").slider({
			min  : 0,
			max  : 100,
			value: paletteValue * 100,   

			slide: function( event, ui ) {
				paletteValue = ui.value / 100;
				updatePalette();
			}
		});
		
		let bgColorChanged = false;
		let oldBackgroundRGBA = backgroundRGBA;
		
		$("#bgColorPicker").spectrum({
			theme: "sp-dark",
			color: backgroundRGBA,
			
			show: function( color ) {
				bgColorChanged = false;	
				oldBackgroundRGBA = backgroundRGBA;				
			},
			move: function( color ) {
				backgroundRGBA = color.toRgb();
				backgroundRGBA.a = 255;
				updatePalette();
			},
		    change: function( color ) {
				bgColorChanged = true;	
			},
			hide: function() {
				if( ! bgColorChanged )
				{
					backgroundRGBA = oldBackgroundRGBA;
					updatePalette();
				}
			}
		});
		
		$("#grayScaleCheckBox").checkboxradio()
			.prop("checked", isGrayScale )
			.on("change", function(event){
				isGrayScale = $(this).prop("checked");
			});
			
		//----- Animation Tab -----
		
		$("#animationSpeedSlider").slider({
			min  : 0,
			max  : 100,
			value: animationSpeed * 100,   

			change: function( event, ui ) {
				animationSpeed = ui.value / 100;
			}
		});		

		$("#paletteConstantSlider").slider({
			min  :  0 * 1000,
			max  : 30 * 1000,
			value: paletteConstantMillis,   

			change: function( event, ui ) {
				paletteConstantMillis = ui.value;
				isPaletteTransition = false;
				paletteStartTime = performance.now();
			}
		});		
		
		$("#paletteTransitionSlider").slider({
			min  :  1 * 1000,
			max  : 30 * 1000,
			value: paletteTransitionMillis,   

			change: function( event, ui ) {
				paletteTransitionMillis = ui.value;
				isPaletteTransition = false;
				paletteStartTime = performance.now();
			}
		});
	}

	//-------------------------------------------------------------------------------------------------------------------
	
	function appendOption( selectElement, opt ){
		let optElem = $("<option></option>");
		optElem.text( opt.text );
		if( opt.selected )
			optElem.attr( "selected", true );
		selectElement.append( optElem );
	}	
	
	//===================================================================================================================
	// Main 
	//===================================================================================================================

	// Generate initial palette.
	generatePalette( startPalette, Math.random() ); 
	z42color.makePaletteGradientRGBA( grayScalePalette, 0, grayScalePalette.length, {r:0,g:0,b:0,a:255}, {r:255,g:255,b:255,a:255}, z42easing.easeLinear );
	
	// Generate initial fractal.
	noise.seed( noiseSeed );
	resizeCanvas();	
	
	// On window resize, resize the canvas to fill browser window dynamically.
	window.addEventListener( 'resize', resizeCanvas, false );

	// On double-click set fullscreen.
	canvas.addEventListener( 'dblclick', toggleFullscreen, false );
	
	// On single-click randomize fractal.
	canvas.addEventListener( 'click',    reseedFractal, false );
	
	// Launch the animation.
	window.requestAnimationFrame( drawInCanvas );

	// Initialize GUI for setting parameters.
	initGui();
}());
</script>
</body>
</html>
